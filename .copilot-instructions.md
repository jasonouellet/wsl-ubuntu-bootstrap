# WSL Ubuntu Bootstrap - Copilot Instructions

<!-- markdownlint-disable MD013 MD022 MD031 MD032 MD040 MD037 -->

## Project Overview

This is an enterprise-grade, organization-agnostic Ansible project for bootstrapping a complete WSL Ubuntu environment. The project evolved from simple GPG key transfer to a production-ready infrastructure-as-code framework with comprehensive CI/CD pipeline and testing.

### Core Objectives
1. **Modularity**: Role-based architecture with clear separation of concerns
2. **Organization Agnostic**: No hardcoded certificates, credentials, or corporate-specific configuration
3. **Quality Assurance**: Comprehensive linting (ansible-lint, shellcheck, yamllint, markdownlint) and testing
4. **CI/CD Integration**: GitHub Actions pipeline for automated validation
5. **Idempotency**: All tasks include proper `changed_when` and `failed_when` conditions
6. **Documentation & Tests First**: Every code change must update tests, docs (README/CHANGELOG), and validation scripts (e.g., `validate.sh`, role-specific tests) before push

## Architecture

### Directory Structure
```
wsl-ubuntu-bootstrap/
├── main.yml                          # Main playbook
├── hosts                             # Inventory file
├── ansible.cfg                       # Ansible configuration
├── group_vars/
│   ├── all.yml                       # Central configuration (role toggles, versions, packages)
│   └── custom.yml.example            # Template for custom variables
├── roles/
│   ├── common/                       # Base system packages (git, curl, wget)
│   ├── ssl-config/                   # Optional SSL/TLS configuration
│   ├── python/                       # Python + pipx + CLI tools
│   ├── nodejs/                       # Node.js + npm
│   ├── dotnet/                       # .NET SDK
│   ├── terraform/                    # Terraform + Hashicorp tools
│   ├── azure-cli/                    # Azure CLI
│   ├── containers/                   # Docker/OCI container tools
│   └── maintenance/                  # System maintenance (cron auto-updates)
├── .github/
│   └── workflows/ci.yml              # GitHub Actions CI pipeline
├── .ansible-lint                     # ansible-lint configuration
├── .yamllint                         # yamllint configuration
├── .markdownlint.yaml                # markdownlint configuration
├── .pre-commit-config.yaml           # pre-commit hooks configuration
├── .gitignore                        # Git ignore rules
└── README.md                         # Documentation

```

### Role Structure (per role)
```
roles/<role-name>/
├── tasks/
│   └── main.yml                      # Main tasks + test/validation tasks
├── vars/
│   └── main.yml                      # Role-specific variables (optional)
├── handlers/
│   └── main.yml                      # Handlers (optional)
└── README.md                         # Role documentation (optional)
```

## Key Technologies

### Ansible
* **Version**: 2.16+
* **Approach**: Host-based localhost execution (no inventory required for local execution)
* **Connectivity**: local connection with become: yes for privilege escalation

### Python Environment
* **System**: Python 3.12.3 with apt-managed python3-full package
* **CLI Tools**: Installed via **pipx** (not pip) for isolation and safety
  * Tools: pre-commit, yamllint, pylint, black
  * Installed for both root and current user
  * PATH management via `/etc/profile.d/pipx.sh` and `~/.bashrc`
* **Development Packages**: Managed via venv if needed (`/opt/python-venv`)

### Node.js
* **Version**: 22 (configurable via `nodejs_version` in group_vars/all.yml)
* **Package Manager**: npm
* **Repository**: NodeSource repository (modern, maintained)
* **PATH Configuration**: `/etc/profile.d/nodejs.sh` for system-wide access

### Linting & Validation Tools
* **ansible-lint**: 6.17.2 - Validates Ansible playbooks and roles
* **shellcheck**: 0.9.0 - Validates shell scripts
* **yamllint**: 1.33.0 - Validates YAML files
* **markdownlint**: Validates Markdown formatting
* **pre-commit**: 4.5.1 - Git hooks for pre-commit validation

### CI/CD Pipeline
* **Platform**: GitHub Actions
* **Triggers**: Push to main, Pull Requests
* **Validation Chain**:
  1. ansible-lint on all playbooks
  2. shellcheck on all *.sh files
  3. yamllint on YAML configs
  4. markdownlint on *.md files
  5. Playbook syntax check: `ansible-playbook main.yml --syntax-check`

## Configuration Management

### Central Configuration: `group_vars/all.yml`

All role toggles, package lists, and versions are centralized here.

**Role Toggles** (enable/disable features):
```yaml
enable_common: true
enable_ssl_config: false              # Optional - no org-specific certs by default
enable_python: true
enable_nodejs: true
enable_dotnet: true
enable_terraform: true
enable_azure_cli: true
enable_containers: true
enable_maintenance: true
```

**Package Management**:
* `common_packages_linux`: Base system packages (git, curl, wget, etc.)
* `python_packages_apt`: APT packages for Python (python3-full, pipx, etc.)
* `python_packages_pip`: pip packages (if needed)
* `nodejs_version`: Node.js version to install

**SSL Configuration** (organization-agnostic):
* `ssl_ca_cert_name`: Empty by default (no organizational cert required)
* If needed: Set to certificate filename (e.g., "ia-root-ca.crt")
* Certificate files placed in `group_vars/` but excluded via `.gitignore` (*.crt, *.key, *.pem)

**Ansible Tools** (for CI/CD):
```yaml
ansible_lint_version: "6.17.2"
shellcheck_version: "0.9.0"
yamllint_version: "1.33.0"
```

### Customization (Local Overrides)
Users can create `group_vars/custom.yml` for local customizations:
* Override defaults from `all.yml`
* Add local-only variables
* File is in `.gitignore` (never committed)

Example template at: `group_vars/custom.yml.example`

## Linting Configuration

### .ansible-lint
```yaml
kinds:
  - playbook: main.yml               # Define main.yml as playbook type

skip_list:
  - '406'                            # git checksum changed
  - '204'                            # lines too long (handled with line folding)
  - schema                           # Skip schema validation

warn_list:
  - '306'                            # id and name variables shadowing
```

**Key Rules**:
* Line length limit: 120 characters (use YAML `>` for folding)
* All shell commands must have `changed_when` or `failed_when`
* Avoid `ignore_errors`, use `failed_when: false` instead
* Commands should use `ansible.builtin.command` unless shell features needed
* File permissions must be explicitly set (mode, owner, group)

### Pre-commit Hooks (.pre-commit-config.yaml)
Validates locally before commits:
* ansible-lint on all YAML files
* shellcheck on all shell scripts
* yamllint on YAML files
* markdownlint on markdown files
* End-of-file fixes

## Task Design Patterns

### Pattern 1: Package Installation with Testing
```yaml
- name: Install package
  ansible.builtin.apt:
    name: package-name
    state: present
  tags:
    - role-name
    - packages

- name: Test package installation
  ansible.builtin.command: package-name --version
  register: package_version
  changed_when: false
  tags:
    - role-name
    - test
```

### Pattern 2: Commands with Safe Failure Handling
```yaml
- name: Run optional command
  ansible.builtin.command: some-command
  changed_when: false                 # Command doesn't change system state
  failed_when: false                  # Fail without blocking playbook
  tags:
    - role-name
    - test
```

### Pattern 3: Shell Commands (when needed)
```yaml
- name: Complex shell operation
  ansible.builtin.shell: |
    export PATH="$PATH:~/.local/bin"
    command1 && command2
  changed_when: false
  tags:
    - role-name
```

### Pattern 4: PATH Configuration (avoiding duplicates)
```yaml
- name: Add tool to PATH
  ansible.builtin.lineinfile:
    path: /etc/profile.d/toolname.sh
    line: 'export PATH="/path/to/tool:$PATH"'
    create: yes
    mode: '0644'
    state: present                    # Prevents duplicates on re-runs
  tags:
    - role-name
```

### Pattern 5: Conditional Blocks
```yaml
- name: Configure optional feature
  block:
    - name: Check if certificate exists
      ansible.builtin.stat:
        path: "/path/to/{{ ssl_ca_cert_name }}"
      register: cert_file

    - name: Install certificate
      ansible.builtin.copy:
        src: "group_vars/{{ ssl_ca_cert_name }}"
        dest: "/etc/ssl/certs/"
        mode: '0644'
      when: cert_file.stat.exists
  when: ssl_ca_cert_name | length > 0    # Only if configured
  tags:
    - role-name
```

## Testing & Validation

### Test Tasks in Every Role
Each role includes `test` tagged tasks:
```bash
# Run all tasks
ansible-playbook main.yml

# Run only test tasks
ansible-playbook main.yml --tags test

# Run specific role only
ansible-playbook main.yml --tags python

# Dry-run (check mode)
ansible-playbook main.yml --check
```

### Syntax Check
```bash
ansible-playbook main.yml --syntax-check
```

### Linting
```bash
ansible-lint main.yml                # Lint playbook
ansible-lint roles/                  # Lint all roles
shellcheck roles/**/*.sh             # Lint shell scripts
yamllint .                           # Lint all YAML files
```

### Pre-commit Validation
```bash
pre-commit run --all-files           # Run all hooks on all files
pre-commit run ansible-lint          # Run specific hook
```

## Deployment Approach

### Local Execution (Recommended for WSL)
```bash
ansible-playbook main.yml
ansible-playbook main.yml --tags nodejs,python
ansible-playbook main.yml -e enable_dotnet=false
```

### Remote Execution (Future)
```bash
# Modify hosts file with remote IP/hostname
# Update connection method in main.yml (if needed)
ansible-playbook -i hosts main.yml
```

### Tag System
* Each task tagged with role name and category (packages, test, etc.)
* Use tags to selectively run portions of playbook:
  * `--tags common` - Run common role only
  * `--tags test` - Run only test/validation tasks
  * `--tags packages` - Run all package installation tasks
  * `--skip-tags azure-cli` - Skip Azure CLI installation

## Organization-Agnostic Principles

### What We Exclude
* Hardcoded organizational certificates (optional, variable-driven)
* Corporate proxy configurations (can be added in custom.yml)
* Specific user credentials or SSH keys
* Organization-specific tool versions (all configurable)
* Proprietary software or repositories

### What We Include (Configurable)
* Optional SSL/TLS support via `ssl_ca_cert_name` variable
* Feature flags to disable unwanted components
* Clear examples and templates for customization
* Support for custom variables via `group_vars/custom.yml`

## Common Workflow

### Adding a New Role
1. Create `roles/new-feature/` directory
2. Add `tasks/main.yml` with:
   * Main installation tasks
   * Test/validation tasks (tagged with `test`)
   * Proper `changed_when` and `failed_when` conditions
3. Update `main.yml` playbook with new role reference
4. Add role toggle to `group_vars/all.yml`
5. Update `.pre-commit-config.yaml` if adding new file types
6. Run linting: `ansible-lint roles/new-feature/`
7. Test: `ansible-playbook main.yml --tags new-feature`

### Fixing Linting Errors
1. Run linter: `ansible-lint main.yml`
2. Fix violations per rule:
   * **line-length**: Use YAML `>` folding syntax
   * **no-changed-when**: Add `changed_when: false` or specify conditions
   * **ignore-errors**: Replace with `failed_when: false`
   * **command-instead-of-shell**: Use `ansible.builtin.command` unless shell features needed
   * **risky-file-permissions**: Add `mode`, `owner`, `group` parameters
3. Validate: `ansible-lint main.yml` (should show 0 failures)

### Pre-commit Hook Setup
```bash
# Install pre-commit (if not already done)
pip install pre-commit

# Initialize hooks in git repository
pre-commit install

# Run hooks on all files (first time)
pre-commit run --all-files

# After setup, hooks run automatically on `git commit`
```

## Current Status

### Completed
✅ Repository restructured as organization-agnostic Ansible project
✅ Centralized configuration in `group_vars/all.yml`
✅ Certificate handling (optional, variable-driven)
✅ 9 roles with comprehensive test tasks
✅ GitHub Actions CI/CD pipeline
✅ All linting tools configured and passing
✅ Pre-commit hooks setup and initialized
✅ PATH management (nodejs.sh, pipx.sh) implemented
✅ All ansible-lint violations fixed (0 errors)

### Latest Achievement
* Fixed all 10 ansible-lint violations:
  * Added `changed_when: false` to all shell commands
  * Replaced `ignore_errors` with `failed_when: false`
  * Fixed line-length violations with YAML folding
  * Added file permissions to lineinfile tasks
  * Fixed command-instead-of-shell violations
  * Configured ansible-lint with proper `kinds:` support

### Next Steps (Optional Enhancements)
* [ ] Add Vagrant support for multi-OS testing
* [ ] Add Molecule for role-level testing
* [ ] Add additional roles (Docker Compose, Kubernetes tools, etc.)
* [ ] Create role templates for faster development
* [ ] Add performance profiling tasks
* [ ] Add backup/restore functionality
* [ ] Document custom variable examples
* [ ] Add Windows Subsystem for Linux specific optimizations
* [ ] Create role inter-dependency tests

## Important Notes

### Python Environment Strategy
* **System packages via apt**: python3-full, pipx, development tools
* **CLI tools via pipx**: Tools requiring latest versions (pre-commit, yamllint, etc.)
* **User isolation**: pipx tools installed for both root and current user
* **PATH handling**: Configured in both `/etc/profile.d/` (system) and `~/.bashrc` (user)
* **Avoid**: Using `pip install --system-wide` (forbidden in Ubuntu 24.04)

### Idempotency Considerations
* All PATH configuration uses `lineinfile` with `state: present` to prevent duplicates
* File creation includes explicit `create: yes` and `mode` parameters
* Shell commands include `changed_when: false` if they don't modify system state
* Use `register` and `when` for conditional task execution

### Security Best Practices
* No passwords stored in playbook (use Ansible Vault if needed)
* No private keys committed to repository (excluded via .gitignore)
* File permissions explicitly set (never rely on defaults)
* Shell commands properly quoted and escaped
* Use `become: no` explicitly for unprivileged tasks

## Git Workflow

### Standard Commit Flow
```bash
# Make changes
nano roles/python/tasks/main.yml

# Pre-commit hooks run automatically
git add .
git commit -m "add: feature description"  # Hooks validate before committing
git push

# GitHub Actions CI runs on push
```

### Bypass Pre-commit (Not Recommended)
```bash
git commit --no-verify
```

## Support & Troubleshooting

### Common Issues

**Issue**: Playbook runs but tools not in PATH

* **Solution**: Tools installed for root only; add `become: no` and export PATH in user shell

**Issue**: ansible-lint fails with schema error

* **Solution**: Ensure `.ansible-lint` has `kinds:` defined for main.yml

**Issue**: lineinfile adds duplicate lines on re-runs

* **Solution**: Use `state: present` instead of `state: absent`,
  ensures idempotency

**Issue**: Shell command marked with changed_when: false fails

* **Solution**: Separate read-only commands from modifying commands;
  use command instead of shell

**Issue**: Pre-commit hooks fail on commit

* **Solution**: Run `pre-commit run --all-files` to fix issues,
  then commit

## Quick Reference Commands

```bash
# Playbook execution
ansible-playbook main.yml
ansible-playbook main.yml --syntax-check
ansible-playbook main.yml --check
ansible-playbook main.yml --tags python
ansible-playbook main.yml --skip-tags azure-cli

# Linting
ansible-lint main.yml
shellcheck roles/**/*.sh
yamllint .
markdownlint "*.md"

# Keep tests/docs/validation updated with code changes
./validate.sh
pre-commit run --all-files
# Update README/CHANGELOG and any role test scripts whenever roles change

# Pre-commit
pre-commit install
pre-commit run --all-files
pre-commit run ansible-lint --all-files

# Git operations
git status
git add .
git commit -m "message"
git push
```

---

**Last Updated**: February 2, 2026
**Ansible Version**: 2.16+
**Python Version**: 3.12.3
**Status**: Production-ready with all linting passing
